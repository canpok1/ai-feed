# GitHub Issue #9 振り返り (KPT)

## Keep (継続すること)

- **Issue駆動開発:** GitHub Issue を起点にタスクを細分化し、計画的に進められた点。
- **段階的な実装とテスト:** 各機能追加・修正ごとにビルドとテストを行い、問題の早期発見に繋がった点。
- **Makefileの活用:** `make test` や `make build` など、プロジェクトの既存のMakefileを活用できた点。
- **Goのテストフレームワーク:** `testing` パッケージと `cobra` の連携でテストを記述できた点。
- **パラメタライズドテスト:** `readURLsFromFile` のテストをパラメタライズドテストにリファクタリングできた点。
- **レビューコメントの活用:** レビューコメントを元に、コード品質とテストの堅牢性を向上できた点。

## Problem (問題点)

- **テストのシミュレーションの難しさ:** `cobra` のフラグの `Changed()` 状態をテストで正しくシミュレートするのに苦労した点。`cmd.Flags().Set()` が `Changed()` に影響しないという挙動の理解に時間がかかった。
- **重複排除ロジックのテストの設計:** 最初、`RunE` 関数内で重複排除ロジックを直接テストしようとして、外部依存（`FetchFeed`）の問題やコードの重複が発生した点。
- **CI設定の確認不足:** CIでテストがコメントアウトされていたことに、PR作成前に気づけなかった点。
- **コミットメッセージの言語統一:** 最初、コミットメッセージの言語が統一されていなかった点（ユーザーからの指摘で修正）。

## Try (次に試すこと)

- **`cobra` のテストプラクティスの事前調査:** `cobra` コマンドのテストを行う際は、`cmd.ParseFlags()` のような正しいシミュレーション方法を事前に確認する。
- **ロジックの分離と単体テストの徹底:** 複雑なロジック（例: 重複排除）は独立したヘルパー関数として抽出し、その関数を直接テストすることで、テストの堅牢性とコードのモジュール性を高める。
- **CI/CDワークフローの初期確認:** プロジェクト開始時や新規機能開発の初期段階で、既存のCI/CDワークフローを確認し、テストが適切に設定されているかを検証する。
- **コミットメッセージのテンプレート化/自動化:** プロジェクトのコミットメッセージの規約を明確にし、可能であればテンプレートやLintツールを導入して自動化を検討する。
- **KPTの定期的な実施:** 今後も定期的にKPTを実施し、開発プロセスの改善に繋げる。

---

# GitHub Issue #9 振り返り (YWT)

## Y (やったこと - Yet)

- `preview` コマンドに `--source` オプションを追加し、URL一覧ファイルからのURL読み込み、バリデーション、重複排除機能を実装した。
- 関連する単体テストを作成し、既存のテストをパラメタライズドテストにリファクタリングした。
- `README.md` に `--source` オプションに関するドキュメントを追加した。
- CIでテストが実行されるようにワークフローを修正した。
- レビューコメントに対応し、コード品質とテストの堅牢性を向上させた。

## W (わかったこと - What)

- `cobra` のフラグの `Changed()` 挙動は `Set()` ではシミュレートできず、`ParseFlags()` を使う必要があることを学んだ。
- テストの対象となるロジックは、可能な限り独立した関数として抽出し、直接テストすることで、テストの信頼性と保守性が向上することを再認識した。
- CI/CDの設定は、開発の初期段階で確認し、適切に設定されていることを確認することの重要性を認識した。
- コミットメッセージの規約統一は、チーム開発において非常に重要であることを再認識した。

## T (次にやること - Try)

- `cobra` コマンドのテストを行う際は、`ParseFlags()` を使用したフラグのシミュレーション方法を標準プラクティスとして確立する。
- 新しい機能や複雑なロジックを実装する際は、まずそのロジックを独立したヘルパー関数として設計し、単体テストを先に作成するTDD（テスト駆動開発）のアプローチを積極的に採用する。
- 今後のプロジェクトでは、CI/CDワークフローの初期設定時にテスト実行ステップが適切に組み込まれていることを必ず確認する。
- コミットメッセージの規約をチーム内で共有し、必要であればGitフックやLintツールを導入して自動チェックを行うことを検討する。
- 定期的な振り返り（KPTやYWT）を継続し、開発プロセスの改善サイクルを回していく。

---

# 振り返り手法の比較と気づき

## KPTとYWTの比較

今回のGitHub Issue #9 の対応においては、**YWT (Yet, What, Try) の方がより振り返りしやすかった**と感じます。

**YWTが振り返りしやすかった理由:**

- **「Yet (やったこと)」の具体性:** 機能追加、テストの修正、CIの改善など、多岐にわたる具体的な「やったこと」を網羅的に整理するのに役立ちました。
- **「What (わかったこと)」の深掘り:** `cobra` のフラグの挙動やテスト設計の課題、CI設定の見落としなど、実際に手を動かして初めて気づいた技術的な「学び」や「洞察」を深く掘り下げ、言語化するのに非常に適していました。単なる問題点の列挙に留まらず、その問題から得られた教訓を明確にできました。
- **「Try (次にやること)」への繋がりやすさ:** 「わかったこと」で得られた学びを直接的に「次にどう活かすか」という具体的な行動計画に繋げやすかったです。

KPTも問題点の特定と行動計画には優れていますが、YWTの「わかったこと」のフェーズが、今回の技術的な試行錯誤とそこからの学びを整理する上で、より効果的だったと感じています。

## 振り返りについて気づいたこと

YWTでの振り返りを通じて、特に以下の点に気づきました。

1.  **具体的な学びの明確化**: 「Yet (やったこと)」で具体的な行動を整理し、「What (わかったこと)」でその行動から得られた教訓や洞察を深掘りすることで、単なる問題点の列挙に終わらず、具体的な「学び」として言語化できる点が非常に有効です。これにより、次にどう活かすべきかが明確になります。
2.  **ポジティブな側面の強調**: 「Yet (やったこと)」のフェーズがあることで、成功した点やうまくいった点を意識的に認識できます。これは、課題解決だけでなく、チームや個人のモチベーション維持にも繋がり、前向きな改善活動を促進します。
3.  **行動への繋がりやすさ**: 「What (わかったこと)」で得られた深い理解が、「Try (次にやること)」という具体的な行動計画に直接的に結びつくため、振り返りの結果が「やって終わり」にならず、実際の改善行動へと繋がりやすいと感じました。